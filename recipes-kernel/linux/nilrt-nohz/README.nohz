==============================
NI Linux Real-Time NOHZ Kernel
==============================

This document describes the recommended application design, configuration
options, and boot parameters required for optimizing real-time (RT) performance
when using the NILRT nohz kernel.

The nohz kernel provided by 'packagegroup-ni-nohz-kernel' is a Linux kernel
configured to omit scheduling-clock interrupts on CPUs that are either idle or
that have only one runnable task (CONFIG_NO_HZ_FULL=y). This avoids the OS
jitter caused by processing scheduling interrupts at the cost of slower
user/kernel transitions, among other things.

Using this kernel configuration is advantageous for application designs in which
RT threads are assigned to dedicated CPU cores and spend most of their execution
time in user-space running polling loops. Consult the full kernel documentation
on this topic[1] for a list of pros/cons.


Installation
============

Using a terminal console (serial, ssh):

  * opkg update

  * opkg packagegroup-ni-nohz-kernel


Application Design Considerations
=================================

  * Use a single RT thread per reserved CPU.

  * Use warm-up iterations. These are "dry-run" iterations in which the
    processing done by the RT threads is disregarded. This allows the kernel to
    load all the data and code from disk into RAM and warm-up the CPU caches.

  * Isolate the CPUs reserved for critical RT threads, and mark them available
    for adaptive-ticks by setting the 'isolcpus' and 'nohz_full' kernel boot
    parameters.[2]
    e.g.
      fw_setenv othbootargs isolcpus=6,7 nohz_full=6,7

    Note: On NI Linux Real-Time (NILRT) systems, CPU 0 is configured to handle
    general interrupts, kernel and system tasks, and should not be reserved for
    critical RT tasks.

  * Use CPU pools (also known as cgroup cpu sets) to configure CPUs reserved for
    critical RT threads versus general system threads:

      - in LabVIEW use the "Real-Time->RT SMP CPU Utilities" palette to
        configure the CPU pools appropriately;

      - when designing RT applications that are not LabVIEW based this can be
        accomplished by setting the CPU mask of the 'system_set' and
        'LabVIEW_tl_set'.
	e.g.
	  echo 0-5 > /dev/cgroup/cpuset/system_set/cpus
          echo 6-7 > /dev/cgroup/cpuset/LabVIEW_tl_set/cpus

  * Set the CPU mask for kernel work queues /sys/devices/virtual/workqueue/*
    e.g.
	for file in `find /sys/devices/virtual/workqueue -name "cpumask"`; do
		echo 1 > "$file" 2>/dev/null
	done

  * Delay the VM statistics timer.
    e.g.
	sysctl vm.stat_interval=120

    Note: This operation requires the full-featured sysctl utility which can be
    installed with 'opkg install procps'.

  * Disable any tracing that might be active.
    e.g.
	echo 0 > "/sys/kernel/debug/tracing/tracing_on"


Additional considerations for C applications:

  * For each RT thread, set the RT scheduler and priority to use
    e.g.
	struct sched_param schedp;
	memset(&schedp, 0, sizeof(schedp));
	schedp.sched_priority = priority;
	return sched_setscheduler(0, SCHED_FIFO, &schedp);

  * Lock current and future memory allocations in RAM to prevent page faults and
    the associated slow disk access.
    e.g.
	mlockall(MCL_CURRENT | MCL_FUTURE);

--

[1] https://www.kernel.org/doc/html/latest/timers/no_hz.html
[2] https://www.kernel.org/doc/html/latest/admin-guide/kernel-parameters.html
