#!/bin/bash
set -e

# MODE determines the operation to be performed
# get or set
declare -r MODE="${1:-}"

NIRECOVERY_MOUNTPOINT=/mnt/NIRECOVERY

# ---------------------- Get Image ----------------------

get_default_image_name () {
	local DeviceDesc=$(fw_printenv -n DeviceDesc 2>/dev/null)
	if [ -z "$DeviceDesc" ]; then
		DeviceDesc="UnknownDevice"
	fi

	local Date=$(date +%F-%H-%M-%S)

	echo $DeviceDesc-$Date
}

get_image_name () {
	local default_image_name=$(get_default_image_name)
	read -e -p "Enter image name (no spaces, no special chars except '-'): " -i "$default_image_name" image_name
	echo $image_name
}

is_image_valid () {
	local image_name=$1
	if [ -z "$image_name" ]; then
		echo "No image name specified. Please specify an image name" && return 1
	fi
	# If image already exists, confirm if it should be overwritten
	if [ -f $NIRECOVERY_MOUNTPOINT/Images/$image_name/systemimage.tgz ]; then
		read -e -p "An image already exits with this name. Overwrite? (y/N): " -i "N" overwrite 
		[ $overwrite != "y" ] && return 1
	fi
	return 0
}

image_get () {
	if ! mount -o remount,rw $NIRECOVERY_MOUNTPOINT; then
		echo "Make sure the media is labeled NIRECOVERY and is writable" && false
	fi

	# If no image name is provided, retry
	local image_name=$(get_image_name)
	while ! is_image_valid $image_name; do
		image_name=$(get_image_name)
	done

	mkdir -p $NIRECOVERY_MOUNTPOINT/Images/$image_name
	nisystemimage getall -x tgz -f $NIRECOVERY_MOUNTPOINT/Images/$image_name/systemimage.tgz
	mount -o remount,ro $NIRECOVERY_MOUNTPOINT
	echo "Done getting image"
}

# ---------------------- Set Image ----------------------

# Presents a list of existing images and let's user select one
select_image_from_list () {
	[ ! -d $NIRECOVERY_MOUNTPOINT/Images ] && return

	readarray -t images <<< "$(find $NIRECOVERY_MOUNTPOINT/Images -name systemimage.tgz | sort | sed "s,$NIRECOVERY_MOUNTPOINT/Images/,," | sed 's,/systemimage.tgz,,')"
	[ -z $images ] && return
	local no_of_images=${#images[@]}

	echo "System images found on media:" >&2

	PS3="Select an image to use for provisioning: "
	select opt in "${images[@]}"; do
		case $opt in
			*)
				if [[ "$REPLY" =~ ^[0-9]+$ ]] && [ $REPLY -gt 0 ] && [ $REPLY -le $no_of_images ]; then
					echo $opt
					break
				fi
				;;
		esac
	done
}

image_set () {
	if [[ $(type -t early_setup) != function ]]; then
		# If we're here, the script was invoked manually i.e., not from init.
		# So do the required setup.
		source /ni_provisioning.common
		early_setup
	fi

	local image_name=$(select_image_from_list)
	[ -z "$image_name" ] && die "No system images found on the media"

	if [[ "$PROVISION_REPARTITION_TARGET" != "y" ]]; then
		ask_for_continue "ReplicateImage" "PROVISION_REPARTITION_TARGET" "$image_name"
	fi

	if [[ $PROVISION_REPARTITION_TARGET == "y" ]]; then
		source /ni_provisioning.safemode.common
		install_safemode

		nisystemimage setall -x tgz -f $NIRECOVERY_MOUNTPOINT/Images/$image_name/systemimage.tgz -p reset -s reset

		# Retain some grubenv settings
		if grep --quiet "^consoleoutenable=" $BOOTFS_MOUNTPOINT/grub/grubenv; then
			grubenv_consoleoutenable=$(grub-editenv $BOOTFS_MOUNTPOINT/grub/grubenv list |grep "^consoleoutenable=" | cut -f 2 -d '=')
		fi
		if grep --quiet "^bootdelay=" $BOOTFS_MOUNTPOINT/grub/grubenv; then
			grubenv_bootdelay=$(grub-editenv $BOOTFS_MOUNTPOINT/grub/grubenv list |grep "^bootdelay=" | cut -f 2 -d '=')
		fi
		rm -rf mkdir $BOOTFS_MOUNTPOINT/grub

		install_grubenv
		set_versions

		echo $LOG_LEVEL > /proc/sys/kernel/printk
		sanity_check

		print_info "Re-enabling automount..."
		enable_automount
		print_done
	fi

	trap - ERR
	exec 1>&3
	exec 2>&4
}

image_${MODE}
